<html>
<head>
<title>CMU 15-418/618 (Spring 2013) Final Project</title>

<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>

<div class="constrainedWidth">
  
<div style="padding-bottom: 10px;">
<div class="title smallTitle">CMU 15-418/618 (Spring 2013) Final Project:</div>
<div class="title" style="width: 900px; padding-bottom: 6px; border-bottom: #000000 2px solid;">
    Interactive CPU-Based Ray Tracer
</div>
</div>

<div class="boldText">
<div>Nathan Slobody, Adam Wright</div>
</div>

<p><a href="proposal.html">Original Project Proposal</a></p>
<p><a href="checkpoint.html">Checkpoint Report</a></p>

<div class="section">Project Summary</div>

<p>
We have implemented a ray tracer utilizing bounding volume hierarchies (BVH) and packetized traversal on the CPU.  The BVH is built using the surface area heuristic (SAH) to produce BVHs that are inexpensive to traverse.  On Monday we plan to demonstrate our ray tracer rendering detailed scenes at interactive or near-interactive rates.
</p>

<div class="section">Background</div>

<p>
Ray tracing is a rendering technique that calculates the color displayed by an image at each pixel by "tracing" a ray through the scene starting at that pixel.  Since a ray may intersect with multiple objects in the scene, finding the point of closest intersection is a search problem which can be highly computation-intensive given the detail in typical images.
</p>
<p>
Naive algorithms for ray tracing can easily take many hours to traverse simple scenes, and even highly-efficient ray tracers can take long lengths of time given a high degree of desired realism.  Our goal was to implement a ray tracer that provides a reasonable level of realistic detail at an interactive frame rate.  
</p>
<p>
The ray tracing problem is embarassingly parallel in the sense that all rays are independent of one another, but the coherence of ray paths quickly breaks down within a typical scene and the resulting divergence can prove problematic for data parallel hardware such as GPUs.  In light of this, we chose to do our primary implementation on multi-core CPUs, where we can take advantage of separate cores that are able to gracefully handle branch instructions.
</p>

<div class="section">Approach</div>

<p>
There are two major axes of our implementation: a bounding volume hiearchy and packetization.
</p>

<p>
The creation of the BVH acceleration structure is done as a pre-processing step before any rays are traced through the scene.  The structure creates a bounding box around an entire model (containing arbitrary numbers of triangles) and recursively sub-partitions the interior triangles into smaller bounding boxes.  The actual triangles are referenced at the leaf nodes, with each leaf holding up to a pre-set number of triangles, which in our case is set to optimize for the SIMD width of our processors.
</p>

<img alt="Bounding Volume Hierarchy"src="bvh.png">

<p>
At each node of the tree, the choice of how to partition the interior triangles into two child nodes is done by evaluating the Surface Area Heuristic, which roughly tries to balance the surface area of the triangles in each child node of the parent BVH node.
</p>

<p>
Since we restricted ourselves to static scenes for the purposes of this project, we only have to build the BVH once.
</p>

<p>
Packetization involves evaluating multiple rays at once.  The normal ray tracing algorithm loops over all pixels on the screen, and for each pixel loops over all scene objects to find intersections.  By packetizing, we group a block of screen pixels together and trace a frustum through the scene rather than individual rays.  If the frustum does not intersect an object, then none of its interior rays will either, and the ray tracer can safely skip those rays in its computations. 
</p>

<p>
In addition, each packet can be easily mapped over a CPU core for high level parallelism by putting all packets into a shared work queue.  This seems to have the additional benefit of slightly reducing contention compared to individual pixels because of the larger compute time for each work item.
</p>

<p>
We are exploring several strategies for paraellizing packet traversal. The first step is to traverse the BVH and determine which rays can possibly intersect which objects. A frustum test is used to determine that the packet intersects the BVH; if it doesn't, all its rays can be disregarded for that object.  Packet-node intersection tests can be done in SIMD to determine which rays in the packet intersect that node.  As the packet descends into the BVH, rays that don't intersect are removed from the packet until there is a list of rays and the triangles in the BVH they each intersect.
</p>

<p>
Once an intersection is found, the rays will reflect or refract, at which point the packet may no longer be coherent (the rays may not be tightly packed or going in similar directions).  From there the computation is done on a single lane of each core to minimized the effects of the resulting divergence.  
</p>

<p>
This approach should decrease the amount of time spent doing intersection tests, and push a little more work towards the part of the code that actually computes the value of each pixel.
</p>

<div class="section">Results</div>

<p>
The Happy Buddha image below contains over a million triangles and, with our current implementation, rendered in less than a second on our laptops (disregarding BVH build time, which only happens once).  We are continuing to iterate and hope to have this down considerably further by Monday as there are still a number of optimizations to make.  We anticipate a render rate of a few frames per second on scenes like this one.
</p>

<img alt="1 million triangle Buddha model"src="buddha.png">

<p>
Below is a table of our render times for both BVH building and traversal, for the different techniques we tried:
</p>

<center>
<table>
    <tr>
        <th rowspan="2">BVH Type</th>
        <th rowspan="2">Build</th>
        <th colspan="3">Traversal</th>
    </tr>
    <tr>
        <th>1 thread</th>
        <th>4 threads</th>
        <th>8 threads</th>
    </tr>
    <tr>
        <td style="text-align: left">Median Split</td>
        <td>1.04s</td>
        <td>7.92s</td>
        <td>2.21s</td>
        <td>1.75s</td>
    </tr>
    <tr>
        <td style="text-align: left">SAH</td>
        <td>8.77s</td>
        <td>3.95s</td>
        <td>1.09s</td>
        <td>0.87s</td>
    </tr>
</table>
</center>

<p>
By simply doing the traversal/pixel color computation across 8 threads on an Intel i7-2630QM CPU (4 physical cores + hyperthreading) we were able to obtain over 4x speedup. Hyperthreading accounts for the fact that we don't get a huge amount more speedup with greater than 4 cores. The near linear speedup is expected, since the splitting up the screen across multiple cores is embarrasingly parallel; each thread can write to its own part of the output image buffer, and threads only have to read from shared data structures, so there is no heavy contention.
</p>

<p>
We got a speedup of about 2x from moving to SAH from BVH in terms of BVH traversal time, but build time increased drastically. This slow down is acceptable to us since we are focusing on getting an interactive static scene, so we only have to build the BVH one time. If there is time we may optimize this build process by not trying so many different splits, and also by reducing dynamic memory allocation.
</p>

<div class="section">References</div>

<p>I. Wald, S. Boulos, and P. Shirley, <em>Ray Tracing Deformable Scenes Using Dynamic Bounding Volume Hierarchies</em>, 2007</p>

<p>I. Wald et al, <em>State of the Art in Ray Tracing Animated Scenes</em>, 2007</p>

<p>I. Wald, T. Ize, and S. Parker, <em>Fast, Parallel, and Asynchronous Construction of BVHs for Ray Tracing Animated Scenes</em>, 2007</p>

<p>Special thanks to Nico Feltman.</p>


<div class="section">List of Work By Each Student</div>

<p>We pair-programmed a good deal of the project and did roughly equal work.  Adam handled more of the BVH construction and Nathan more of the packetization.</p>

</div>

</body>
</html>
